---

# testing for who is running the playbook to be able to intelligently associate
# a user when installing in a protected sirecotry like /opt/nvm.
# WARNING!! This only makes it available to that specific user and not people associated
# with a group see https://github.com/morgangraphics/ansible-role-nvm/issues/26
- name: "Who is running this playbook?"
  command: whoami
  register: nvm_whoami
  changed_when: false

- name: Set a fact with the user name running the playbook.
  set_fact:
    login_user: "{{ nvm_whoami.stdout }}"

- name: Set full nvm_profile path | Default
  set_fact:
    nvm_profile: "$HOME/.bashrc"
  when: nvm_profile == '.bashrc'

- name: Set full nvm_profile path | Custom Path
  set_fact:
    nvm_profile: "{{ nvm_profile }}"
  when: nvm_profile != '.bashrc'

# ERROR HANDLING
- name: test to ensure symbiotic variables are declared | nvm_dir AND nvm_profile
  fail:
    msg: "If setting a custom nvm_dir directory e.g. /opt/nvm, nvm_dir MUST be used in combination with nvm_profile"
  when: nvm_dir and nvm_profile == '.bashrc' and nvm_install != 'git'

- name: test to ensure symbiotic variables are declared | nvm_dir AND nvm_install = git
  fail:
    msg: "If installing via GIT nvm_install: git MUST be used in combination with nvm_dir and include the full path e.g. nvm_dir: '$HOME/.nvm'"
  when: not nvm_dir and nvm_install == 'git'



# ENVIRONMENT SHELL TESTING

# https://github.com/morgangraphics/ansible-role-nvm/issues/18
- name: determine shell in which we are running
  block:

    - name: set default found path
      set_fact:
        found_path: ''

    - name: test for shells
      command: "which {{ item }}"
      with_items:
        - bash
        - dash
        - zsh
        - csh
        - tcsh
      register: nvm_shell_path
      when: item in nvm_profile
      changed_when: nvm_shell_path is undefined

    - name: set found path
      set_fact:
        found_path: "{{ nvm_shell_path.results | selectattr('stdout', 'defined') | map(attribute = 'stdout') | list | first }}"
      when: nvm_shell_path.results | selectattr('stdout', 'defined') | map(attribute = 'stdout') | list | length > 0

    - name: set bash command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'bash' }
      when: '"bash" in nvm_profile'

    - name: set zsh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'zsh' }
      when: '"zsh" in nvm_profile'

    - name: set csh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'csh' }
      when: "'csh' in nvm_profile and 'tcsh' not in nvm_profile"

    - name: set tcsh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'tcsh' }
      when: "'tcsh' in nvm_profile"

    - name: "!WARNING! set unrecommended default for any other nvm_profile value !WARNING!"
      set_fact:
        user_shell: { 'executable': '/etc/bash', 'flags': '-ic', 'alias': 'bash' }
      when: (nvm_shell_path is undefined) or (found_path | bool)

    - name: does profile file exist | Default
      stat:
        path: "{{ nvm_profile }}"
      register: nvm_profile_file_test

    - name: register profile_file_test result | Default path
      set_fact:
        nvm_profile_file: "{{ nvm_profile_file_test.stat }}"

    - name: Create profile file if it does not exist
      file:
        mode: 0777
        path: "{{ nvm_profile }}"
        state: touch
      when: not nvm_profile_file.exists
      become: true

  when: nvm_profile | length != 0

# UNINSTALL
- name: uninstall nvm
  import_tasks: uninstall.yml
  when: uninstall

# I don't want the rest of the playbook running when uninstall = true 
# It defeats the purpose of the uninstall in the first place
- name: Run everything else when uninstall = false
  block:

  # CLEAN INSTALL OF NVM
  - name: uninstall nvm
    import_tasks: uninstall.yml
    when: clean_install

  # WGET (DEAULT) OR CURL
  - name: Installing via curl or wget
    block:

    - name: Check if wget or curl is installed
      command: "which {{ nvm_install }}"
      register: nvm_cmd
      changed_when: "nvm_cmd.rc != 0"

    - name: Determine if install type wget
      set_fact:
        run_command: 'wget -qO-'
      when: "'/wget' in nvm_cmd.stdout"

    - name: Determine if install type curl
      set_fact:
        run_command: 'curl -o-'
      when: "'/curl' in nvm_cmd.stdout"

    # TODO: https://github.com/morgangraphics/ansible-role-nvm/issues/26
    - name: Create custom nvm_dir if it does not exist
      file:
        mode: 0775
        path: "{{ nvm_dir }}"
        state: directory
        owner: "{{ login_user }}"
      become: true
      become_user: root
      when: nvm_dir | length != 0

    # There are some potential security concerns with piping the install.sh script to whatever shell alias is defined: Risk is Low but not absolute
    # https://blog.dijit.sh//don-t-pipe-curl-to-bash
    # https://news.ycombinator.com/item?id=12766049
    # https://sandstorm.io/news/2015-09-24-is-curl-bash-insecure-pgp-verified-install
    - name: Install NVM
      shell: >
        set -e pipefail
        && {{ run_command }} https://raw.githubusercontent.com/nvm-sh/nvm/v{{ nvm_version }}/install.sh |
        NVM_SOURCE={{ nvm_source }} NVM_DIR={{ nvm_dir }} PROFILE={{ nvm_profile }} {{ user_shell.alias }}
      args:
        warn: false
        executable: "{{ user_shell.executable }}"
      register: nvm_install_result
      changed_when:
        - "'already installed' not in nvm_install_result.stdout"
      failed_when:
        - "'Permission denied' in nvm_install_result.stderr"
        - "'not found' in nvm_install_result.stderr"
        - "'No such file or directory' in nvm_install_result.stderr"

    when: nvm_install in ['curl', 'wget']


  # GIT
  # Running the install.sh script will clone the repo anyway
  # While the NVM documentation says you should always run install.sh there is
  # GIT specific doumentation shows it working as a clone, and additon to
  # the profile and then sourcing the .nvm.sh script. We don't need that here
  - name: install via git
    block:

      - name: Check if git is installed
        command: "which {{ nvm_install }}"
        register: nvm_cmd
        changed_when: "nvm_cmd.rc != 0"

      - name: Clone NVM Git Repo
        git:
          dest: "{{ nvm_dir }}"
          repo: 'https://github.com/nvm-sh/nvm.git'
          version: "v{{ nvm_version }}"
        when: "'/git' in nvm_cmd.stdout"

      - name: Add NVM to nvm_profile
        blockinfile:
          block: |
            export NVM_DIR="{{ nvm_dir }}"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" # This loads nvm
          create: yes
          marker_begin: "Installed nvm via {{ role_repo }} START"
          marker_end: "{{ role_repo }} END"
          mode: 0644
          path: "{{ nvm_profile }}"
          state: present

    when: "nvm_install == 'git'"

  - name: Update profile permissions to lock it down after writing
    file:
      mode: 0644
      path: "$HOME/{{ nvm_profile }}"
    become: true
    become_user: root
    when: not nvm_profile_file.exists

  - name: Check NVM Version | Default # noqa 305
    shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm --version\"' }}"
    register: nvm_version_response
    changed_when: nvm_version_response.rc != 0


  # NVM CONFIGURATION

  - name: LTS Check
    set_fact:
      nodejs_version: --lts
    when: "nodejs_version == 'lts'"

  # This scenario handles the first run/install of NVM because this will automatically
  # alias the specified version as default - This should handle most use cases
  - name: Install Node # noqa 305
    shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm install ' +  nodejs_version + '\"' }}"
    register: nvm_node_version_response
    changed_when: "'already installed' not in nvm_node_version_response.stderr"

  # In the event there are multiple versions of Node being installed/used/upgraded
  # on the same machine we'll need to alias the default version accordingly
  - name: Set default version of Node if multiple versions exist # noqa 305
    shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm alias default ' +  nodejs_version + '\"' }}"
    when:  default

  - name: Run whatever nvm_commands are there # noqa 305
    shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"' +  item + '\"' }}"
    register: nvm_commands_response
    with_items:
      "{{ nvm_commands }}"
    when: nvm_commands | length > 0


  # REMOVE AUTOCOMPLETE

  - name: Searching for autocomplete string in the file
    lineinfile:
      path: "{{ nvm_profile }}"
      regexp: "\\$NVM_DIR/bash_completion"
      state: absent
    check_mode: yes
    changed_when: false
    register: nvm_autocomplete_response

  - name: Remove NVM autocomplete in nvm_profile
    lineinfile:
      path: "{{ nvm_profile }}"
      regexp: "\\$NVM_DIR/bash_completion"
      state: absent
    changed_when: "'nvm source string already' not in nvm_install_result.stdout
      and 'Appending bash_completion source' in nvm_install_result.stdout"
    when: (not autocomplete | bool) and (nvm_autocomplete_response.found > 0)

  when: not uninstall | bool
